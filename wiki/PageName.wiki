{{{

import dpkt

STREAM_MAGIC = 0xacde
STREAM_VERSION = 5
TC_NULL = 0x70
TC_REFERENCE =	0x71;
TC_CLASSDESC = 	0x72;
TC_OBJECT = 	0x73;
TC_STRING = 	0x74;
TC_ARRAY = 	0x75;
TC_CLASS = 	0x76;
TC_BLOCKDATA = 	0x77;
TC_ENDBLOCKDATA =	0x78;
TC_RESET = 	0x79;
TC_BLOCKDATALONG= 0x7A;
TC_EXCEPTION = 	0x7B;
TC_LONGSTRING = 	0x7C;
TC_PROXYCLASSDESC =	0x7D;
TC_ENUM =		0x7E;
TC_MAX = 		0x7E;

baseWireHandle = 0x7e0000;

SC_WRITE_METHOD = 0x01;
SC_SERIALIZABLE = 0x02;
SC_EXTERNALIZABLE = 0x04;
SC_BLOCK_DATA = 0x08;  

SC_ENUM = 0x10;

class WorkingTable:    
    classdesc_table = {}
    depth = 0
    prevobj = ''
    currobj = ''
    handle_class_map = {}
    handle_cnt = 0
    
    # input: either handle or L<classname> without ;
    def getClassDesc(self,classtype):
        #FIXME make sure first char is typecode or handle
        if type(classtype) == type(2L):
            #if not classtype in 
            classtype = self.handle_class_map[classtype]
        else: classtype = classtype[1:]
        return self.classdesc_table[classtype]

    # input: either handle or L<classname> without ;
    def get_format(self,classtype):
        #FIXME make sure first char is typecode or handle
        if type(classtype) == type(2L):
            #if not classtype in 
            classtype = self.handle_class_map[classtype]
        else: classtype = classtype[1:]
        return self.classdesc_table[classtype].iterate()
    #each class is defined onece,
    #TODO classname existence check 
    def store_class(self,classname,classDesc):
        #print hex(self.handle_cnt),'store cltype',classname,fields
        self.classdesc_table[classname] = classDesc
    def set_handle(self, classname):
        #print 'handle',hex(self.handle_cnt),classname
        self.handle_class_map[self.handle_cnt] = classname
        self.handle_cnt += 1        

_debug_ = WorkingTable()
# TOFIX, figure out how handle is assigned

def prim_typecode_size(code):
    if code in 'BZ': return 1
    elif code in 'SC': return 2
    elif code in 'FI': return 4
    elif code in 'DJ': return 8
    else: return -1

# input is Lclass/type/string; or <class_handle> or <prim_type_code> or [...
# return Lclass.type.string or <class_handle> or ]Lclass.type.
def get_class_type(str):
    #print 'gclasstype',[str]
    if not str[0] in 'BCDFIJSZ[L\x00':
        print 'fix meeeeeeeeeeeeeeeee',[str]
        sys.exit()
    if str[0] == '[':
        if str[1] != 'L':
            return str[0:2]
    s = str.split(';')
    if len(s) > 1: return '.'.join( s[0].split('/'))
    else:
        return Jint(str).value-baseWireHandle
        
        
class Jint(dpkt.Packet):
    __hdr__ = [
        ('value','I',0)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        self.data = ''
        
class UTF(dpkt.Packet):
    __hdr__ = [
        ('slen','H',0)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        self.data =  buf[2:2+self.slen]
        #print 'UTF',self.slen,self.data
        
class NewString(dpkt.Packet):
    __hdr__ = [('tc','B',TC_STRING),
        ('slen','H',0)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        self.data =  buf[3:3+self.slen]
        #print 'string',[self.data]
        _debug_.set_handle('???NewString:'+self.data),

class NullReference(dpkt.Packet):
    __hdr__ = [('tc','B',TC_NULL)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        print 'TC_NULL'
        self.data = ''

        
class Fields(dpkt.Packet):
    __hdr__ = [
        ('count','H',0)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        offset = 2
        print 'count',self.count
        self.ftypes = []
        for i in xrange(self.count):
            typecode = buf[offset]
            offset += 1
            if typecode in 'BCDEFIJSZ':
                s = UTF(buf[offset:])
                offset += len(s)
                print i,'field',typecode,[s.data]
                self.ftypes.append((typecode,s.data))
            elif typecode in '[L':
                s = UTF(buf[offset:])
                offset += len(s)
                if ord(buf[offset]) == TC_STRING:
                    className1 = NewString(buf[offset:])
                    offset += len(className1)
                    print i,'field',typecode,[s.data],[className1.data]
                    self.ftypes.append((className1.data,s.data))
                elif  TC_REFERENCE==ord(buf[offset]):
                    offset += 1
                    h = buf[offset:offset+4]
                    offset += 4
                    print i,'field',typecode,[s.data],[h]
                    self.ftypes.append((h,s.data))
                else:
                    print buf[offset],'not impl'
            else:
                print 'sth wrong',typecode
        self.data = buf[2:offset]
        #print dpkt.hexdump(self.data)

    def iterate(self):
        print self.ftypes


def Content(buf,classtype = None):
    tc = ord(buf[0])
    obj = None
    #print 'concltype',classtype,dpkt.hexdump(buf[:16])

    if tc == TC_OBJECT:
        obj = NewObject(buf=buf,classtype=classtype)
        obj.patch()
    elif tc == TC_BLOCKDATA:
        obj = Blockdata(buf)
    elif tc == TC_CLASS:
        obj = NewClass(buf)
    elif tc == TC_ARRAY:
        obj = NewArray(buf=buf,classtype=classtype)
        obj.patch()
    elif tc == TC_STRING:
        obj = NewString(buf)
        print 'content:',[obj.data]
    elif tc == TC_CLASSDESC:
        obj = NewClassDesc(buf)
    elif tc == TC_REFERENCE:
        obj = PrevObject(buf)
        print 'conref:',_debug_.handle_class_map[obj.handle]
    elif tc == TC_ENUM:
        obj = NewEnum(buf)
    elif tc == TC_NULL:
        obj = NullReference(buf)
    else:
        print 'Content unknown',tc,dpkt.hexdump(buf[:64])
    return obj


class PrevObject(dpkt.Packet):
    __hdr__ = ( ('tc','B',TC_REFERENCE),
        ('handle','I',0x7e0000))
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        self.handle = self.handle - baseWireHandle
        self.data = ''
        
class Blockdata(dpkt.Packet):
    __hdr__ = [ ('tc','B',TC_BLOCKDATA),
        ('size','B',1)]
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        if self.tc != TC_BLOCKDATA:
            print self.tc, 'blockdata long not impl'
        self.data = buf[2:2+self.size]
        print 'blockdata',self.size,dpkt.hexdump(self.data)
        
class ClassDescInfo(dpkt.Packet):
    __hdr__ = [
        ('flags','B',1)]
    superClassDesc = None
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        offset = 1
        print 'classDescInfo flag',hex(self.flags)
        self.fields = Fields(buf[offset:])
        offset += len(self.fields)
        if ord(buf[offset]) != TC_ENDBLOCKDATA:
            print 'not implement class annotation', dpkt.hexdump(buf[0:offset+32])
        offset += 1

        # superClassDesc, classDesc, 
        print 'super',
        if ord(buf[offset]) == TC_NULL:
            print 'TC_NULL'
            offset += 1
        elif ord(buf[offset]) == TC_REFERENCE:
            ref = PrevObject(buf[offset:])
            self.superClassDesc = _debug_.getClassDesc(ref.handle)
            print self.superClassDesc.className            
            offset+= len(ref)
        else:
            self.superClassDesc = NewClassDesc(buf[offset:])
            offset += len(self.superClassDesc)
        self.data = buf[1:offset]
    def iterate(self):
        if self.fields is None: return []
        # TODO imple try catch AttributeError
        if self.superClassDesc is None: return self.fields.ftypes
        if type(self.superClassDesc) == type(2L):
            #return _debug_.get_format(self.superClassDesc)
            # hack to test the guess, fix handle later
            return _debug_.get_format(self.superClassDesc)+self.fields.ftypes
        return self.superClassDesc.classDescInfo.iterate() + self.fields.ftypes
        
    

class NewClassDesc(dpkt.Packet):
    __hdr__ = [
        ('tc','B',TC_CLASSDESC)]
    className = None
    
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)        
        if self.tc != TC_CLASSDESC:
            print self.tc,'NewClassDesc exception',dpkt.hexdump(buf[0:64])
        offset = 1

        className = UTF(buf[offset:])
        print 'class',[className.data]
        self.className = className.data
        _debug_.set_handle(self.className)
        offset = 1+len(className)
        if offset<2:
            print 'NewClassDesc exception',dpkt.hexdump(buf[0:64])

        serialVersionUID = buf[offset:4+offset]
        #print 'serialVersionUID',Jint(serialVersionUID).value,dpkt.hexdump(serialVersionUID)
        offset += 4
        newHandle = buf[offset:4+offset]
        #print 'newHandle',Jint(newHandle).value,dpkt.hexdump(newHandle)
        offset += 4    
        self.classDescInfo = ClassDescInfo(buf[offset:])
        offset += len(self.classDescInfo)        
        self.data = buf[1:offset]
        #TODO, put fields here?
        _debug_.store_class(self.className, self)        

    def iterateData(self,buf):
        if not self.classDescInfo.superClassDesc is None:
            offset = self.classDescInfo.superClassDesc.iterateData(buf)
        else:
            offset = 0
        classname = self.className
        formats = self.classDescInfo.fields.ftypes
        idx = 0
        for (f,vname) in formats:
            size = prim_typecode_size(f[0])
            print cl2(classname),idx,[f],vname,
            #dpkt.hexdump(buf[offset:offset+64])
            idx +=1
            if size > 0:
                value = buf[offset:offset+size]
                offset = offset + size
                print dpkt.hexdump(value)
            elif ord(buf[offset]) == TC_NULL:
                offset += 1
                print 'NULL'
            else:
                obj  = Content(buf[offset:],self)
                offset += len(obj)
                
        flags = self.classDescInfo.flags
        if flags == 0x3 :
            while(ord(buf[offset]) != TC_ENDBLOCKDATA):
               obj = Content(buf[offset:])
               offset += len(obj)                                  
            offset +=1
        elif offset<len(buf) and ord(buf[offset]) == TC_ENDBLOCKDATA:
            #offset += 1
            print 'Object: eat one 0x78, dont know why it is here'
        return offset
    
    def iterate(self):
        if self.classDescInfo is None: return []
        return self.classDescInfo.iterate()

def decode_array_data(buf,classdesc):
    size = Jint(buf)
    #FIXME, when len(Jint) doesn't work?
    offset = len(size)
    clsize =-1    
    #assert first char is [
    if classdesc.className[1] != 'L':
        print 'arr size',size.value, classdesc.className
        clsize = prim_typecode_size(classdesc.className[1])
        for i in xrange(size.value):
            print classdesc.className[1],i,
            print dpkt.hexdump(buf[offset:offset+clsize])
            offset += clsize  
    else:
        print 'arr size',size.value,classdesc.className
        for i in xrange(size.value):
            print cl2(classdesc.className[1:]),i,
            obj = Content(buf[offset:],classdesc.className)
            offset += len(obj)
    return offset

class NewArray(dpkt.Packet):
    __hdr__ = [('tc','B',TC_ARRAY)]

    def patch(self):
        self.unpack(self.buf)
        self.buf = None
        
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        offset = 1
        formats = []
        self.classDesc = readClassDesc(buf[offset:])
        offset += len(self.classDesc)
        #print 'type',type(self.classDesc)
        if type(self.classDesc) == type(PrevObject()):
            self.classDesc = _debug_.getClassDesc(self.classDesc.handle)

        _debug_.set_handle('???arr instance')           
        offset+=decode_array_data(buf[offset:],self.classDesc)
        self.data = buf[1:offset]

def readClassDesc(buf):
    tc = ord(buf[0])
    obj = None
    #print 'concltype',classtype,dpkt.hexdump(buf[:16])

    if tc == TC_CLASSDESC:
        obj = NewClassDesc(buf)
    elif tc == TC_REFERENCE:
        obj = PrevObject(buf)
        print 'classref:',_debug_.handle_class_map[obj.handle]
    elif tc == TC_NULL: 
        obj = NullReference(buf)
    else:
        print 'ClassDesc unknown',tc,dpkt.hexdump(buf[:64])
    return obj
    
class NewEnum(dpkt.Packet):
    __hdr__ = [('tc','B',TC_ENUM)]
    def unpack(self,buf):
        dpkt.Packet.unpack(self, buf)
        offset = 1
        self.classDesc = readClassDesc(buf[offset:])
        offset += len(self.classDesc)
        global _debug_
        classname = self.classDesc.className
        _debug_.set_handle('???enum')     
        name = NewString(buf[offset:])      
        print 'enum_name',[name.data]  
        offset += len(name)
        self.data = buf[1:offset]
                        
def cl2(classname):    return '.'.join(classname.split('.')[-2:])
class NewObject(dpkt.Packet):
    __hdr__ = [
        ('tc','B',TC_OBJECT)]
    classtype = None
    def patch(self):
        self.unpack(self.buf)
        self.buf = None
                
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        offset = 1
        formats = []
        self.classDesc = readClassDesc(buf[offset:])
        offset += len(self.classDesc)
        #print 'type',type(self.classDesc)
        if type(self.classDesc) == type(PrevObject()):
            self.classDesc = _debug_.getClassDesc(self.classDesc.handle)
        
        #newhandle
        _debug_.set_handle('???instance')
           
        #classdata decoding
        offset += self.classDesc.iterateData(buf[offset:])
       
        self.data = buf[1:offset]


    def iterate(self):
        if self.classDesc is None: return []
        return self.classDesc.iterate()


class JSER(dpkt.Packet):
    __hdr__ = (
        ('magic','H',STREAM_MAGIC),
        ('version','H',1))

    # assume only one object 
    def unpack(self, buf):
        dpkt.Packet.unpack(self, buf)
        offset = self.__hdr_len__

        obj = Content(buf[offset:])
        offset += len(obj)
        if offset < len(buf):
            print dpkt.hexdump(buf[offset-16:])             
            
    def readObject0(self,buf):
        _debug_.depth += 1       
        _debug_.depth -= 1       
        

if __name__ == '__main__':
    import dpkt,sys
    p = JSER(file(sys.argv[1]).read())


}}}